---
title: Using custom response models
---

The `GraphQLQueryPager` supports not only returning collections of a query's `Data` type, but also custom response types. The custom response types can either be a collection or a single object. This is useful when you want to transform the raw response into custom models for consumption in your application.

## Transforming existing responses types

The `GraphQLQueryPager` class conforms to the `Publisher` protocol, and provides a `map` method that allows you to transform the raw response into a custom response type. When used this way, the `GraphQLQueryPager` will operate over generated `Data` types, but allow each `Data` type to betransformed into a custom response type. This is especially useful when you want to reuse a single pager in multiple places, transforming the raw data into view models.

In this example, we take a `GraphQLQueryPager` that returns a `Result<PaginationOutput<MyQuery.Data, MyQuery.Data>>`, and transform the raw response into a custom response type of `Result<[Person], Error>`.

```swift
// This `GraphQLQueryPager` will return a `Result` of `PaginationOutput<MyQuery.Data, MyQuery.Data>`
let initialQuery = MyQuery(first: 10, after: nil)
let pager = GraphQLQueryPager.makeQueryPager(
    client: client,
    initialQuery: initialQuery,
    pageResolver: { page, paginationDirection in
        switch paginationDirection {
        case .next:
            return MyQuery(first: 10, after: page.endCursor ?? .none)
        case .previous:
            return nil
        }
    },
    extractPageInfo: { data in
        CursorBasedPagination.Forward(
            hasNext: data.values.pageInfo.hasNextPage ?? false,
            endCursor: data.values.pageInfo.endCursor
        )
    }
)

// Elsewhere in the application
let cancellable = pager.map { result in
    switch result {
    case .success((let paginationOutput, let source)):
        // We may or may not care about the source, but we can use it to transform the response or pass it through as needed.
        // In this example, we ignore the source and transform the response into a custom response type.
        let pages = paginationOutput.previousPages + [paginationOutput.initialPage] + paginationOutput.nextPages
        let people = pages.flatMap { page in
            data.values.nodes.map { Person(id: $0.id, name: $0.name) }
        }
        return Result<[Person], Error>.success(people)
    case .failure(let error):
        return .failure(error)
    }
}.sink { result in
    // NOTE: This is not guaranteed to run on the main thread. Dispatch to the main thread if necessary.
    switch result {
    case .success(let people):
        // Handle the people
    case .failure(let error):
        // Handle the error
    }
}
```

## Creating `GraphQLQueryPager` that returns custom response types

The `GraphQLQueryPager` class can also be initialized with a custom type in mind. When used this way, the `GraphQLQueryPager` will operate over the custom response type, and not the raw `Data` type. This is useful when you want to create a pager that returns a custom response type, and you don't want to transform the raw response into a custom response type.

We provide a convenience method for transforming collection types in this manner. 

In this example, we take a `GraphQLQueryPager` that returns a `Result<PaginationOutput<MyQuery.Data, MyQuery.Data>>`, and transform the raw response into a custom response type of `Result<([Person], UpdateSource), Error>`.

```swift
let initialQuery = MyQuery(first: 10, after: nil)
let pager = GraphQLQueryPager.makeQueryPager(
    client: client,
    initialQuery: initialQuery,
    pageResolver: { page, paginationDirection in
        // As we only want to support forward pagination, we can return `nil` for reverse pagination
        switch paginationDirection {
        case .next:
            return MyQuery(first: 10, after: page.endCursor ?? .none)
        case .previous:
            return nil
        }
    },
    extractPageInfo: { data in
        CursorBasedPagination.Forward(
            hasNext: data.values.pageInfo.hasNextPage ?? false,
            endCursor: data.values.pageInfo.endCursor
        )
    },
    transform: { data in
        data.values.nodes.compactMap { node in
            Person(id: node.id, name: node.name)
        }
    }
)
```

This supports single object types as well, such as a `Result<(MyResponseModel, UpdateSource), Error>`:

```swift
let initialQuery = MyQuery(first: 10, after: nil)
let pager = GraphQLQueryPager.makeQueryPager(
    client: client,
    initialQuery: initialQuery,
    pageResolver: { page, paginationDirection in
        // As we only want to support forward pagination, we can return `nil` for reverse pagination
        switch paginationDirection {
        case .next:
            return MyQuery(first: 10, after: page.endCursor ?? .none)
        case .previous:
            return nil
        }
    },
    extractPageInfo: { data in
        CursorBasedPagination.Forward(
            hasNext: data.values.pageInfo.hasNextPage ?? false,
            endCursor: data.values.pageInfo.endCursor
        )
    },
    transform: { previousPages, initialPage, nextPages in
        let allPages = previousPages + [initialPage] + nextPages
        let people = allPages.flatMap { page in
            data.values.nodes.map { Person(id: $0.id, name: $0.name) }
        }
        return MyResponseModel(people: people)
    }
)
```

## Creating convenience initializers for `GraphQLQueryPager`

If your application only uses a specific type of pagination, it is simple to declare a custom `GraphQLQueryPager` convenience initializer that can be used throughout your application. This allows you to easily instantiate a pager without worrying about cases that your application does not support.

For example, if your pagination scheme only supports forward pagination and offsets, you can declare a custom `GraphQLQueryPager` convenience initializer that only supports forward pagination and offsets. In this example, we declare two initializers for forward offset pagination: one with a `transform`, and one without:

```swift
extension GraphQLQueryPager {
  static func makeForwardOffsetQueryPager<InitialQuery: GraphQLQuery>(
    client: ApolloClientProtocol,
    watcherDispatchQueue: DispatchQueue = .main,
    queryProvider: @escaping (OffsetPagination.Forward?) -> InitialQuery,
    extractPageInfo: @escaping (InitialQuery.Data) -> OffsetPagination.Forward
  ) -> GraphQLQueryPager where Model == PaginationOutput<InitialQuery, InitialQuery> {
    GraphQLQueryPager.init(
      client: client,
      initialQuery: queryProvider(nil),
      watcherDispatchQueue: watcherDispatchQueue,
      extractPageInfo: pageExtraction(transform: extractPageInfo),
      pageResolver: { page, direction in
        guard direction == .next else { return nil }
        return queryProvider(page)
      }
    )
  }

  static func makeForwardOffsetQueryPager<InitialQuery: GraphQLQuery, T>(
    client: ApolloClientProtocol,
    watcherDispatchQueue: DispatchQueue = .main,
    queryProvider: @escaping (OffsetPagination.Forward?) -> InitialQuery,
    extractPageInfo: @escaping (InitialQuery.Data) -> OffsetPagination.Forward,
    transform: @escaping (InitialQuery.Data) throws -> Model
  ) -> GraphQLQueryPager where Model: RangeReplaceableCollection, T == Model.Element {
    GraphQLQueryPager.init(
      client: client,
      initialQuery: queryProvider(nil),
      watcherDispatchQueue: watcherDispatchQueue,
      extractPageInfo: pageExtraction(transform: extractPageInfo),
      pageResolver: { page, direction in
        guard direction == .next else { return nil }
        return queryProvider(page)
      },
      initialTransform: transform,
      pageTransform: transform
    )
  }
}

private func pageExtraction<InitialQuery: GraphQLQuery, P: PaginationInfo, T>(
  transform: @escaping (InitialQuery.Data) -> P
) -> (PageExtractionData<InitialQuery, InitialQuery, T>) -> P {
  { extractionData in
    switch extractionData {
    case .initial(let value, _), .paginated(let value, _):
      return transform(value)
    }
  }
}

private func pageExtraction<InitialQuery: GraphQLQuery, PaginatedQuery: GraphQLQuery, P: PaginationInfo, T>(
  initialTransfom: @escaping (InitialQuery.Data) -> P,
  paginatedTransform: @escaping (PaginatedQuery.Data) -> P
) -> (PageExtractionData<InitialQuery, PaginatedQuery, T>) -> P {
  { extractionData in
    switch extractionData {
    case .initial(let value, _):
      return initialTransfom(value)
    case .paginated(let value, _):
      return paginatedTransform(value)
    }
  }
}
```
