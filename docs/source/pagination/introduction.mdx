---
title: Pagination
---

Apollo Pagination provides a convenient and easy way to interact with and watch paginated APIs. It provides a flexible and powerful way to interact with paginated data, and works with both cursor-based and offset-based pagination. Its key features include:

- Watching paginated data
- Forward, reverse, and bidirectional pagination support
- Multi-query pagination support
- Support for custom model types

Apollo Pagination provides two classes to interact with paginated endpoints: `GraphQLQueryPager` and `AsyncGraphQLQueryPager`. They have very similar APIs, but the latter supports `async`/`await` for use in asynchronous contexts.

## Using a `GraphQLQueryPager`

The `GraphQLQueryPager` class is intended to be a simple, flexible, and powerful way to interact with paginated data. While it has a standard initializer, it is recommended to use the convenience initializers, which simplify the process of creating a `GraphQLQueryPager` instance. The convenience initializers are static methods on the `GraphQLQueryPager` class, prefixed with `make`.

For example, in order to initialize a `GraphQLQueryPager` that paginates a single query in the forward direction with a cursor-based pagination, you can use the `makeForwardCursorQueryPager` method:

```swift
let pager = GraphQLQueryPager.makeForwardCursorQueryPager(
    client: apolloClient,
    queryProvider: { page in
        MyQuery(first: 10, after: page?.cursor ?? .none)
    },
    extractPageInfo: { data in
        CursorBasedPagination.Forward(
            hasNext: data.values.pageInfo.hasNextPage ?? false,
            endCursor: data.values.pageInfo.endCursor
        )
    }
)
```

In this example, the `GraphQLQueryPager` instance is initialized with a closure that provides the query to be executed, and another closure that extracts the pagination information from the query result. The `GraphQLQueryPager` instance can then be used to fetch the paginated data, and to watch for changes to the paginated data.

## Subscribing to results

The `GraphQLQueryPager` class can fetch data, but the caller must subscribe to the results in order to receive the data. A `subscribe` method is provided which takes a closure that is called whenever the pager fetches a new page of data. The `subscribe` method is a convenience method that ensures that the closure is called on the main thread.

```swift
// Guaranteed to run on the main thread
pager.subscribe { result in
    switch result {
    case .success(let data):
        // Handle the data
    case .failure(let error):
        // Handle the error
    }
}
```

The `GraphQLQueryPager` is also a Combine `Publisher`. As such, all `Publisher` methods are available, such as `sink`, `assign`, `map`, `filter`, and so on.

```swift
// Can run on any thread
pager.sink { result in
    switch result {
    case .success(let data):
        // Handle the data
    case .failure(let error):
        // Handle the error
    }
}
```

## Custom response types

The `GraphQLQueryPager` class is designed to work with any response type. By default, when initialized without a `transform`, the `GraphQLQueryPager` class will return a `Result` of `PaginationOutput`. This object contains three fields: `previousPages`, `initialPage`, and `nextPages`.

The `previousPages` field contains all the pages that have been fetched in the reverse direction, and exposes the paginated query's `Data` type. The `initialPage` field contains the first page of data that was fetched, and is an instance of the initial query's `Data` type. The `nextPages` field contains all the pages that have been fetched in the forward direction, and is a list of the paginated query's `Data` type.

If you want to use a custom response type, you can provide a `transform` closure when initializing the `GraphQLQueryPager` instance. This closure is called whenever the pager fetches a new page of data, and is used to transform the raw response into the desired response type.

```swift
struct Person {
    let id: String
    let name: String
}

let pager = GraphQLQueryPager.makeForwardCursorQueryPager(
    client: apolloClient,
    queryProvider: { page in
        MyQuery(first: 10, after: page?.cursor ?? .none)
    },
    extractPageInfo: { data in
        CursorBasedPagination.Forward(
            hasNext: data.values.pageInfo.hasNextPage ?? false,
            endCursor: data.values.pageInfo.endCursor
        )
    },
    transform: { data in
        data.values.nodes.map { Person(id: $0.id, name: $0.name) }
    }
)
```

In this example, the `GraphQLQueryPager` instance is initialized with a `transform` closure that transforms the raw response into an array of `Person` objects. Alternatively, we can make use of the `GraphQLQueryPager`'s `map` method to achieve the same result:

```swift
pager.map { data in
    data.values.nodes.map { Person(id: $0.id, name: $0.name) }
}.sink { result in
    switch result {
    case .success(let people):
        // Handle the people
    case .failure(let error):
        // Handle the error
    }
}
```

## Fetching Data

The `GraphQLQueryPager` class provides several methods to fetch paginated data: `fetch`, `refetch`, `loadNext`, `loadPrevious`, and `loadAll`.

`fetch`: Fetches the first page of data. Must be called before `loadNext` or `loadPrevious` can be called.
`refetch`: Cancels all ongoing fetch operations and resets the pager to its initial state. Fetches the first page of data.
`loadNext`: Fetches the next page of data. Can only be called after `fetch` has been called.
`loadPrevious`: Fetches the previous page of data. Can only be called after `fetch` has been called.
`loadAll`: Fetches all pages of data. If no initial page is detected, it will first call `fetch` to fetch the first page of data. Will continue to fethc all pages until a `PageInfo` object indicates that there are no more pages to fetch. This function is compatible with forward, reverse, and bidirectional pagination.

## Cancelling ongoing requests

The `GraphQLQueryPager` class provides a `cancel` method, which can be used to cancel any ongoing fetch operations as well as cease any watcher subscriptions. Once cancelled, the pager's state is reset. Any subscriber that was subscribed to the pager will remain subscribed and will continue to receive updates; the `cancel` function does not affect the pager's subscribers.

## Error handling

There are two broad categories of errors that the `GraphQLQueryPager` class can throw: errors as a result of network operations, or errors as a result of usage. A network error is exposed to the user when the pager encounters a network error, such as a timeout or a connection error, via the `Result` that is passed to the subscriber. Usage errors, such as cancellations or attempting to begin a new fetch while a load is in progress, are thrown as `PaginationError` types (for `AsyncGraphQLQueryPager`) or exposed as callbacks in each fetch method (for `GraphQLQueryPager`). Note that `GraphQLQueryPager`'s callbacks are optional, and the user can choose to ignore them.

### Usage errors in `GraphQLQueryPager`

The `fetch`, `refetch`, `loadNext`, `loadPrevious`, and `loadAll` methods all have a completion handler that is called with a `Result` type. This `Result` type can contain either the paginated data or a `PaginationError` type. Common pagination errors are attempting to fetch while there is already a load in progress, or attempting to fetch a previous or next page without first calling `fetch`.

```swift
// Attempting to fetch a previous page without first calling `fetch`
pager.loadNext { error in
    if let error {
        // Handle error
    } else {
        // We have no error, and are finished with our fetch operation
    }
}

// Note that we can silently ignore the error
pager.loadNext()
```

### Usage errors in `AsyncGraphQLQueryPager`

The `AsyncGraphQLQueryPager` class can throw a `PaginationError` type directly, as opposed to exposing it via a completion handler. As an inherently asynchronous type, the `AsyncGraphQLQueryPager` can intercept an error thrown within a `Task` and forward it to the caller.

```swift
// Attempting to fetch a previous page without first calling `fetch`
try await pager.loadNext()

// Similarly, we can silently ignore the error
try? await pager.loadNext()
```
